0.不要在头文件定义外部连接的全局变量
	这会导致重定义
	解决方法：
		使用extern声明全局变量在其他源文件已经定义，再在源文件中定义外部连接的全局变量
		可以定义内部连接的全局变量(常量最好这么做)
0.1.头文件里应该写什么
	https://blog.csdn.net/weixin_42018112/article/details/82357002
0.2.头文件和源文件的文件名没有直接关系
1.为什么字符串常量可以被赋值给char*
	C中字符串常量是char*类型的，而c++的字符串常量是const char*的，但是为了向C兼容，所以可以赋值给char*
	解决：不直接使用字符串常量，而是赋值给一个const char*后在使用这个量
2.类中的const，const static，static怎么赋值？
	const使用构造函数初始化列表初始化
	const static直接赋值或cpp内赋值
	static 在cpp中赋值
3.const对象和成员函数
	const对象只能使用const成员函数。
4.内部链接，外部链接，无链接性/可见性
	内部连接的在其他编译单元内不可见，外部连接的在其他编译单元内可见
	include和连接无关
	全局变量（非const或static）和类定义（不是声明）和函数定义（不是声明）都是外部连接的
	在全局中，未使用extern的变量“声明”，例如：int x;都是定义，默认值为0
	const全局变量和static全局变量是内部连接
	extern声明：其他编译单元内已经有外部连接形式的该名字变量
	extern定义：定义为外部连接
	namespace中的东西的链接性和在全局定义的时候是一样的。也可以在namespace中使用extern来声明变量或函数已经在cpp中定义了
	无连接性一般为局部变量
5.存储类型
	static（内部连接） extern（外部连接） auto（局部变量） register（寄存器变量）
	register原意是使用cpu寄存器来存储自动变量。但随着处理器变得越来越复杂，在C++11中，register的作用变成只是分配自动变量（局部变量）了，和以前的auto一样了
6.宏的独特功能
	#x   转义为变量名x	#define F(x) cout<<#x;
	x##y 标志粘贴       #define F(a) char *a##_string;
7.基础类型的默认值
	除了全局变量的默认值为0外所有局部变量都没有默认值（值为内存指向的地址存储的内容）
8.静态初始化的相依性
	如果全局变量之间相互引用却无法按预想的顺序初始化就会出现问题
	解决方法：《C++编程思想》10.4
		1.参考iostream
		2.使用带有static变量的函数
9.基类实例能否转为派生类？
	也许
	若派生类实现了以基类为参数的构造器或赋值运算符
10.forword declaration class
	class提前声明的话只能用他们来定义指针或引用(不能定义一个按值的实例),也能拿来做友元这类不会使用到被提前声明的类的成员的操作。
	不能用来当作基类被派生