## 内存结构：

BSS段：存放未初始化的全局变量和静态变量。在编译的时候就决定好了内容，没有定义的变量默认值为0
数据段：存放已初始化的全局变量和静态变量
代码段
栈
堆

## 记得delete！！！

## 多使用const

如果不修改参数内容，参数应该加上const。
如果不修改this内容，成员函数应该加上const
如果禁止修改返回值，返回值应该加上const

## 小心溢出！！！

整型的溢出一般发生在**加减乘**时

## 字符串结尾是\0!!!!!

c++11规定string的结尾应该也是\0，但是不一定编译器实现了

## 第一个命令行参数是执行的文件的文件名

## c++的换行

![image-20210920104847095](D:\ALL\Program\c++\note\image-20210920104847095.png)

回车\r
换行\n

```c++
//linux下
std::cout<<"hhhhhhhh\r"<<"xiha"<<std::endl;	//输出xihahhhh
```

## 引用在声明的时候必须定义

## 基本类型大小

在16位机中，int跟short int一样2字节，long 4字节； 在32位机中，int 跟long int一样4字节，需要64位int就用long long int，即int64; 在64位机中，int还是4字节，long int 8字节，long也是8字节。
double在32位机器和64位机器下都是8字节的。long long是c++11的内容

## 内存对齐

### 原因

现在大多数计算机是一次性取多个字节如64字节，如果同一个数据分布在两个这样的64字节块中，就需要做更多操作

32位机器可以访问没有对齐的数据，只是速度比较慢。其他类型的机器不允许访问没有对齐的数据，会直接出错

### 规则

每个平台都有**对齐系数**，32位linux/windows默认为#pragma pack(4)，64位linux/windows默认为#pragma pack(8)，可以通过#pragma pack(n)来设置，n可以为1，2，4，8，16
**有效对齐位**：min(对齐系数，结构体中最长数据类型的长度)
0.结构体的起始地址是？？？？
1.假设结构体的第一个成员的offset是0，则之后每个成员的地址都为**有效对齐位和该成员大小的最小值**的整数倍
2.结构体总大小为有效对齐位的整数倍

## sizeof运算符

sizeof数组名获得的是整个数组的大小
sizeof指向数组的指针(不是数组名，例如传递到函数中)获得的是指针的大小。这被称为数组退化

sizeof是运算符

## cast/显式类型转换

dynamic_cast   static_cast 等都是关键字不用加std::

### dynamic_cast\<typname\>(param)

**运行期完成**。能够在类层次上转型。失败返回空指针(typename为指针时)，抛出异常std::bad_cast（typename为引用时）。传入空指针则抛出异常

运行期间通过虚表定位的type_info检查转换是否正确

### const_cast\<typename>(param)

改变const和volatile标记，但也只能改变这两个标记。但是只有源数据不是被声明为const的数据才真的能够修改，试图用const_cast修改源数据为const的局部数据不会报错，但实际的修改并不会被应用到原来的数据上。但是修改全局const常量（全局常量在只读数据段上）会在运行时报错（segment fault）
typename只能是指针或引用

```c++
//-------const_cast--------
Child child;
const Base*base=&child;
cosnt_cast<Base*>(base);			//可以
const_case<Child*>(base);			//不可以
testAssist(const int*i){
    int *ii=const_cast<int*>(i);
    *ii=20;
}
const int iii=100;
test(){
    int i=10;
    testAssist(&i);			//i会被修改
    const int ii=15;
    testAssist(&ii);		//ii不会被修改
    testAssist(&iii);		//修改iii会在运行期间报错
}
```

### static_cast\<typename>(param)	

**编译期完成**。当typename可以隐式转换为param的类型或param的类型可以隐式转换为typename的时候，结果正常。
但是不能实现int*到char\*的转变因此还是需要使用原始的办法，但是可以实现从void\*到int\*之类的变换，以及int到float的变换。在父子类指针或引用变换的时候最好使用dynamic_cast

```c++
//--------static_cast---------
Base*base=new Base;
Child*child=new Child;
static_cast<Child*>(base);		//可能会出问题
static_cast<Base*>(child);
static_cast<int>(3.152f);
int i=1000000;
char *ic=static_cast<char*>(&i);
```



### reinterpret_cast							

进行一些危险且绝大部分是不可移植的操作

**限制**：
不能将指针转换为更小的整型或浮点数，不能将函数指针转为数据指针

```c++
//-------reinterpret_cast----------
//32位下。long位四字节
struct dat{short a;short b};
long value=0xA224B118;
dat*p=reinterpret_cast<dat*>(&value);
cout<<hex<<p->a;	//b118
```

## 声明和定义

只声明：
全局变量和静态变量默认为0（int）（BSS段上的数据可以在编译阶段进行初始化）
局部变量的值和编译器有关，一般为地址指向的堆栈的空间上未被清理的数值（堆栈上的数据为堆栈上之前的数据，是动态变化的，若在运行期间默认初始化为0，会消耗运行时间）
**const**没有默认值必须定义（无论全局还是局部变量）
**类中的成员**：基础类型和指针都不会有默认值（理论上）而是野值，自定义类型默认调用无参数构造函数。引用必须赋值，否则编译器报错。static成员只能在类的内部声明，定义要在类的外面进行定义（应该在cpp文件中定义，在h文件中定义会出现重定义的错误）。const成员变量需要在构造函数的初始化列表中进行初始化。static const成员有两种初始化方法，一是直接在声明的时候定义，二是在cpp文件中定义

```c++
//Test.h
class Test{
public :
	static int a;
	const int b;
	statc const int c;
	statc const int d=120;
	Test();
}
//Test.cpp
int Test::a=11;
coinst int Test::c=150;
Test::Test():b(29){};
```



## 函数指针

函数名就是一个函数指针

double (\*pf)(int);
(\*pf)是函数
pf是函数指针

pf(4);
(\*pf)(4);
都可以**调用函数**

函数指针指向带有**默认参数的函数**的时候需要写全所有函数，而且通过函数指针调用函数不能使用默认参数

### 复杂函数指针解析

```c++
//---------原则：先右后左----------
int(*func)(int *,int(*)(int));
//func是一个函数指针。它的参数是一个int指针和另一个函数指针（参数为int，返回值为int），它的返回值是一个int
int (*(*func)[5])(int);
//func是一个数组，它的元素是函数指针，这些函数指针指向参数为int返回值为int的函数
int(*(*func)(int))[3];
//func是一个函数指针，它指向参数是int，返回值是指针（这个指针指向int[3]）的函数
int(*(*func)[5][6])[5][6];
//func是一个5*6的数组，这个数组的元素是指针，这些指针指向一个int类型的5*6数组
```



## 左值右值

## 函数原型

原型中参数可以没有名字

ANSI C没有参数列表表示将在后面定义参数列表
C++没有参数列表表示没有参数，要表示在后面定义参数列表应该使用...
void func()
void func(...)

## 锁

## socket

## fstream

eof是在读取到之后才设置的

## const

const变量不能传给一般指针
一般变量可以传给const指针
成员函数后面加const表示该成员函数不改变字段或只改变mutable字段

const全局常量一般会被存在符号表，只在必须的时候（如取地址运算&）才分配空间。const局部常量不会存在符号表，是伪常量，是会分配内存空间的

```c++
const int a=100;
void test(){
	const int a=100;//1
	int *aa=(int*)&a;
	*aa=10;		//若注释1，则报错
}
```



## volatile

防止编译器优化代码消除平时多余的读操作（多线程，中断处理，多任务时使用）

一般数据存储在堆栈中，在实际使用时读到寄存器再操作，使用volatile可以再每一次使用数据的时候都强制要求编译器从堆栈中再读取到寄存器中

## typedef

typedef 原类型 新类型

## 引用

传递数组的时候只能用指针而不能用引用

较大的对象使用引用

较小的例如基本类型直接按值传递。//(没想明白)或者如果需要修改这个基本类型，应该使用指针
如果在多线程中传递基本类型的时候使用了按引用传递可能编译器会优化成按值传递。需要使用std::ref强制按值传递



## 模板

### 万能引用

&&在模板中不代表右值引用，而是万能引用，既可以引用左值也可以引用右值

### 函数模板

#### typename class的区别

```c++
//用于指出嵌套类型的成员是类型而不是变量或函数
class X{
public:
    class XX{};
};
template<typename T>
void f(T&t){
    T::XX xx;//无法判断XX是泛型T的成员变量或函数还是类型。编译器报错
    typename T::XX xx;//指定T::XX是一个类型而不是成员函数或变量。
    typedef typename T::XX TXX;//使用typedef简化结果
    TXX x; 
}

```

#### 函数优先级

非模板函数>模板具体化>函数模板

#### 具体化

```c++
template<typtename T>
void func(T a,T b){};

template<>void func(int a,int b){};//显式具体化
template<> void func<int>(int a,int b);

template void func(char a,char b);//显示实例化

func<double>(...);			//显示实例化

A a,A b;
func(a,b);					//隐式实例化
```

隐式实例化、显式实例化、显示具体化统称具体化
实例化的定义是依据于模板的，具体化的定义没有完全依据于模板的定义

#### 编译器对函数的选择（从高到低）

参数数目和类型完全匹配：非模板函数高于模板函数
提升转换：如char和short转为int，float转为double
标准转换：如int转为char和short，double转为float
用户定义的转换：如类声明中定义的转换

完全匹配可以执行一些无关紧要的转换，如T-->T&  T&-->T   .......

#### decltype(expression) var

**C++11**

通过expression的结果指定var的类型

```c++
int x;
decltype(x) y; //y是int类型。stage 1，未被括号包围的标识符
decltype(fun(x)) y;  //y的类型和func(x)的返回类型相同。stage 2.函数的返回
decltype((x)) y;    //y的类型为int&。stage3.如果expression是一个左值，var的类型为该左值类型的引用。要进入第三步，不能是未被括号包围的标识符，因此被括号包围的标识符会将var的类型解释为标识符类型的引用
decltype(100L) y;   //y的类型是long。stage4.
```



#### 后置返回类型(auto的第三个用法)

**C++11**

可用于自动判断返回类型
常与decltype一起使用

```c++
template<typename T1,typename T2>		//g++ 中可以省略decltype
auto func(T1 l,T2 r)->decltype(l+r)
{
    return l+r;
}
```

## explicit

禁止隐式类型转换
explicit只能用于类中的一些特殊函数（拷贝构造函数，赋值运算符，转换函数）

## 默认参数

默认参数在声明中必须指出，在定义中可以忽略

函数指针指向带有默认参数的函数的时候需要写全所有函数，而且通过函数指针调用函数不能使用默认参数

## 存储持续性

自动存储持续性：局部变量。函数定义内的声明的变量，在函数或代码块结束的时候自动被清理。 **栈**上数据
静态存储持续性：整个程序运行中都存在。函数定义外的全局变量或使用static定义的变量（不一定是函数内的） **数据段**内数据
线程存储持续性：生命周期与所属线程一样长。使用thread_local（C++11）定义
动态存储持续性：用new或malloc分配的变量。**堆**上数据

## mutable

即使结构或类为const，定义为mutable的字段依旧能够改变
可以直接改变，也可以在成员函数中改变

```c++
struct A{
public:
	mutable int x;
}
const A a;
a.x=100;
```

## extern

1.定义外部链接
2.声明变量已经有外部链接的变量
3.调用其他语言代码

```c++
extern "c"{

}
```

## 语言链接性

C++中的函数编译后内部标识符不会和原文件中的函数名相同（因为函数重载），而C的函数编译后内部标识符和原文件的相同。如果直接在C++中使用编译好的C函数。在链接的时候会出错

## new运算符初始化

```c++
int *a=new int(6);    //分配空间并赋值为6
struct A{
    int a;
    int b;
}
A * b=new A{1,2}       //C++11.分配空间并对各个字段赋值
```

## 定位new运算符

指定new创建的内存块的内存地址
不能使用delete
//不确定是在堆还是在栈上分配的

## 对象数组

```c++
Stock stocks[10]={
    Stock(1),
    Stock(2),
    Stock(3)
}
```

## 作用域

全局（文件）
局部（代码块）
类

## 作用域内枚举

**C++11**

```c++
enum egg{Small,Big};
enum t_shirt{Small,Big};    //重定义出错

enum class egg{Small,Big};
enum class t_shirt{Small,Big};   //只能通过egg::Small这样的形式使用，不会出错
//不会隐式转换为int，因此无法通过标准输出直接输出。但是可以显示转型。
//int a=int(egg::Small);
//这样的是不允许的: int a= egg::Small;
```

## 随机数

void srand(int) 指定种子
int rand()          返回随机数

```c++
#include<time.h>
#include<random>
int main(){
	srand(time(NULL));
	rand()%100+1	//1-100
}
```



## 临时量

## 类

### 继承

私有继承后派生类不能隐式向上转换为基类，需要显示调用

```c++
class ClassBase{}
class ClassChild:private ClassBase{}
void testAssist(ClassBase*t){}
void test(){
	ClassChild c;
	testAssist(&c);						//错误
	testAssist((ClassBase*)&c);			//正确
}
```



|                    | public继承       | protected继承    | private继承      |
| ------------------ | ---------------- | ---------------- | ---------------- |
| public 字段        | public           | protected        | private          |
| protected字段      | protected        | ptotected        | private          |
| private字段        | 通过基类方法访问 | 通过基类方法访问 | 通过基类方法访问 |
| 是否能隐式向上转型 | 能               | 只能在派生类中   | 不能             |

#### 构造函数

派生类构造函数若没有显示调用基类构造器，则默认隐式调用基类无参数构造器，若没有无参数构造器将报错

基类构造函数总是要在派生类构造函数调用之前调用。所以显示调用基类构造函数要在初始化列表上调用

```c++
class A{
public:
	A(int x){}
}
class B:public A{
public:
	B():A(3){}
}
```

#### 析构函数

若有派生需求，一定要virtual

派生类默认调用基类析构函数

c++规范不允许显式调用析构函数。虽然编译能通过

#### 友元函数

派生类不能直接调用基类的友元函数。但可以间接调用，例如把this转为基类类型之后使用

### 多重继承(MI)

若没有对每一个基类都使用关键字，默认private

```c++
class Class c:public A,B{}  		//公有继承A，私有继承B
class Class c:public A,public B{}	//公有继承A和B
```

#### 问题

若继承的基类树中有两个或以上数量的同一个类，当试图转换为这个类时，会报错，除非使用**虚基类**进行**虚继承**

```c++
class Worker{}
class Singer:public Worker{}
class Writer:public Worker{}
class SingerWriter:public Singer,public Writer{}
void testAssist(Worker*w){}
void test(){
	SingerWriter sw;
	testAssist(&sw);		//报错
}
```

若多重继承有重复的方法，直接调用重复的方法会报错(**不一定**)。可以使用作用域解析或重新定义该函数

```c++
//假设Singer和Writer都有show()
SingerWriter sw;
sw.show();		//报错
sw.Singer::show()		//通过
//------------------
class SingerWriter{
	public:
		void show(){
			Singer::show();
		}
}
```



#### 虚基类

必须显示地调用**虚基类的构造函数**

```c++
//接上文
class Singer:virtual public Worker{}		//虚继承
class Writer:virtual public Worker{}		//虚继承
class SingerWriter:/*virtual*/public Singer,Writer{	//只保留一份Worker
    public:
    	SingerWriter():Writer(),Singer(),Worker(){}
}
```



### 多态

实现方法：
不适用virtual，直接在子类中写

如果没有virtual，则根据当前类型判断使用哪个函数。若将子类转型成父类再调用，则调用的是父类的方法
如果有virtual，若方法是通过指针或引用调用的，则会使用虚函数表调用到子类的方法

！！！！！**父类的析构函数一定声明为virtual**！！！！！

### 虚函数

#### 联编/绑定

静态绑定（早期绑定）/动态绑定（晚期绑定）

#### 原理

定义了虚函数的类都会有虚函数表，若子类重载了虚函数表，则只需修改子类的虚函数表中对应函数的地址

#### 返回类型协变

子类覆盖基类虚函数可以改变返回类型为基类虚函数返回类型的子类。但是参数必须和基类虚函数参数一致

#### 限制

1.子类继承基类时，不能“重载”虚函数，"重载"虚函数会直接隐藏原来的函数定义。但是可以通过转成基类指针来使用被隐藏的虚函数

```c++
class Parent{
public:
	virtual void func(int x){}
};
class child:public(Parent){
public:
	virtual void func(){}
};
Child c;
c.func();	//可以
c.func(3);	//不可以
Base*cc=&c;
cc->func(3);	//可以
```

2.如果基类的虚函数有多个重载，则在子类覆盖基类虚函数的时候需要把所有的重载版本都定义出来。如果只定义一个，则其他版本的重载会被隐藏

3.友元函数不能是虚函数

#### 纯虚函数

没有定义只有声明的虚函数
c++没有**abstract**关键字

```c++
virtual void func()=0;
```



### 隐式类型转换

[彻底理解c++的隐式类型转换 - apocelipes - 博客园 (cnblogs.com)](https://www.cnblogs.com/apocelipes/p/14415033.html)

不会报错（包括基本类型的隐式类型转化（long->int））

可以使用explicit关闭隐式类型转换，但是依旧可以显式类型转换

一般情况下只能使用一个参数实现隐式类型转换，使用{}可以使用多个参数实现隐式类型转换

```c++
class Class{
public:
    Class(int x,int y){}
}
void testClassAssist(Class c){}
void testClass(){
    testClassAssist({12,13});
    Class a={12,13};
};
```



#### **经典面试题**

```c++
string str="hello world";	//右边的"hello world"显示通过接收const char*参数的string构造函数隐式转换成string。1.C++11后，再通过移动构造函数创建str。2.C++11前，再通过拷贝构造函数创建str。
//所以理论上（17前）会有两个string被创建。实践上编译器会使用复制省略这种机制让这段代码只生成一个string
//c++17把复制省略标准化了，所以理论上也是只有一个string被创建
```

#### 隐式类型转化序列

一个隐式类型转换序列包括一个初始标准转换序列、一个用户定义转换序列、一个第二标准转换序列

```
零个或一个由标准转换规则组成的标准转换序列，叫做初始标准转换序列。比如数组退化成指针，函数退化成指针，数值之间的类型转换
零个或一个由用户自定义的转换规则构成的用户定义转换序列。比如用户自定义的转换函数
零个或一个由标准转换规则组成的标准转换序列，叫做第二标准转换序列。和第一个一样，都是标准转换规则。
```

如果一个转化序列包含两个用户自定义类型就不会转化成功

```c++
struct A{
	A(B&b){...}
}
struct B{
    B(int str){...}
}
void func(A&a){
	...
}
void func2(B&b){
    ...
}
void main(){
     func(1);		//不能通过
	long i=10L;
    func2(i)		//能通过
}
```



### 初始化顺序

//大概。先使用构造函数中的初始化列表初始化，然后默认，然后调用构造函数

使用初始化列表初始化，则初始化顺序并不是初始化列表的顺序，而是类字段定义的顺序

```c++
class Class{
public:
	int _x;
	int _y;
	Class(int x,int y):_y(y),_x(x){}
}
//初始化顺序是_x->_y
```



### 默认析构函数

不会delete或free

### 默认构造函数

不会new，不会初始化内建类型

### 默认复制赋值运算符

仅当没有自定义移动复制构造函数和移动复制赋值运算符的时候会自动生成

按位复制

显式调用基类赋值运算符：BaseClass::operator=(param);

### 默认复制构造函数

仅当没有自定义移动复制构造函数和移动复制赋值运算符的时候会自动生成

### 默认移动构造函数和移动赋值运算符

只有当一个类没有自定义任何自己的**拷贝构造函数**或**析构函数**或**复制赋值函数**（或者定义了但是没使用const）,并且其所有数据成员都可以移动构造或移动赋值时，编译器会为它合成

### 模板

#### 具体化

```c++
C<int>c				   	   //隐式实例化
template class C<int>		//显式实例化
template<> class C<int>{}	//显式具体化

template<typename T> 
class B<T,int>{}			//部分具体化.如果有多个模板使用，则编译器选择具体化最高的模板
```

编译器在需要对象之前，不会生成类的隐式实例化

```c++
C<int>* c;		//还未生成类的隐式实例化
c=new C<int>	//生成类的隐式实例化
```

#### 将模板用作参数

```c++
template<typename T>
class TemplateAssist{};
template<template<typename typename T>class U>		//c++17中，class可以替换为typename
class Template{}
Template<TemplateAssist> a;					//可以
Template<TemplateAssist<int>>b;				//不可以
TemplateAssist<Template<TemplateAssit>>;	//可以
TemplateAssist<Template>;					//不可以
```

#### 友元

分为三种：
1.非模板友元
2.约束模板友元
3.非约束模板友元

```c++
template<typename T>
void f2(T&t){}					//模板需要提前声明
template<typename C,typename D>
void f3(C&c,D&d){}
template<typename T>
class Class{
    public:
    	friend void f1();		//非模板友元
		friend void f2(Class<T>&t);	//约束模板友元
    	template<typename C,typename D>
    	friend void f3(C&c,D&d);	//非约束模板友元
}
```

#### 模板别名

c++11

```c++
using a=Class<int>;			//c++11
```

### 嵌套类

。。。

## 拷贝构造函数和赋值运算符

编译器会自动生成，可以使用delete取消自动生成

```c++
class Person
{
public:
	Person(const Person& p) = delete;
	Person& operator=(const Person& p) = delete;
}
```

### 拷贝构造函数

拷贝构造函数和移动构造函数不一样

//拷贝构造函数必须以引用的方式传递参数

若自己定义了拷贝构造函数，则需要定义移动构造函数否则无法使用隐式类型转换定义实例（除非拷贝构造函数用的是const引用参数）

```c++
class Class{
private:
    int x;
public:
    Class(int x){this->x=x;}
	Class(Class&cla){x=cla.x}
}
Class c=15	//error。需要定义移动构造函数

```

拷贝构造函数经常出现在：
	1.直接定义 A a=a2;
	2.传参void func(A a){}; func(a);
	3.返回值 A func(){A a; return a;}

### 赋值运算符

若自己定义了赋值运算符，则需要定义移动赋值运算符（除非赋值运算符的参数有加const）否则无法使用隐式类型转换复制实例

```c++
class Class{
private:
	int x;
public:
    Class(int x){this->x=x;}
    Class& operator=(Class&cla){x=cla.x;return *this;}
}
Class c(13);
c=15;		//erro。需要定义移动赋值运算符
```

## 复制省略

只用于**构造时**！！！，移动赋值运算符不会复制省略

编译器为了删除临时量的机制

g++可以通过‑fno‑elide‑constructors关闭复制省略

## 右值引用

### 移动构造函数

创建移动构造函数的时候一定要记得如果有指针字段，在把指针字段复制到this之后要把参数的指针字段设置为**NULL**，否则可能会被析构函数delete

只有当一个类没有自定义任何自己的**拷贝构造函数**或**析构函数**或**复制赋值函数**（或者定义了但是没使用const）,并且其所有数据成员都可以移动构造或移动赋值时，编译器会为它合成移动构造函数

## 运算符重载

​	new,delete都是可以重载的
​	当运算符重载函数作为类方法时，运算符左边的得是这个类的实例。对于特殊的情况（如double*myClassInstance）可能需要非成员函数的运算符重载函数

```c++
class Time{
    int x;
public:
    Time(int x):this->x(x){}
    Time operator+(Time&time){
        return Time(this->x+time.x);
    }
}
Time time1(2),time2(3);
Time time3=time1+time2;
Time time4=time1.operator+(time2);
```



### 限制

运算符重载函数的参数必须有一个是用户自定义的类型，防止重载基本类型的运算符
用法不能改变，如不能%a（%前没有任何东西）。也不会修改运算符的**优先级**
不能创建新运算符
**不能重载**以下运算符：
	sizeof
	.				成员运算符
	.*			  成员指针运算符
	::			  作用域解析运算符
	?:			 条件运算符
	typeid	   一个RTTI运算符
	各种cast运算符

以下运算符只能通过成员函数重载（其他的都可以是非成员函数重载）：
	=
	()
	[]
	->

### 自增自减运算符的重载

各有两种
operator++()是前缀版本
operator++(int)是后缀版本

## 转换函数

用于将定义了这个函数的类转换成需要的类型。当不指定explict的时候可以进行隐式类型转换，指定explict后不可以使用隐式类型转换

只能在被转换的类中定义
不能指定参数和返回类型（但是有返回值）

```c++
class Class{
public:
    operator int{return 1;}
}
Class c;
int a=c;
cout<<c;
```

### bool重载

可以直接把该类实例当作bool值用。1.特殊语境，如if判断。2.位运算

可以通过在其前面加上**explicit**禁止出现在特殊语境之外的使用

```c++
class Class{
private:
    bool isTrue=false;
public:
    operator bool(){return isTrue;}
    //explicit operator bool(){return isTrue;}
}
Class c;
if(c){
    ...
}
if(!c){
    ...
}
c<<1		//如果加了explicit就报错
```



## 友元

友元函数
友元类
友元成员函数

友元函数常见用法：
1.重载<<以使用cout输出自定义类的实例

```c++
ostream& operator<<(ostream&out,const Time&time);
```

## 列表初始化

## 数组退化

sizeof数组名得到的是数组的大小，但是传递给函数后数组退化成指针，sizeof只能获得指针的大小。

可以用模板解决或者直接使用**std::array**

## 正则表达式

效率低下，能不用就不用

## 多线程

### 关键字thread_local

### 原子库atomic

### thread

#### 创建

任何函数对象都可以用于创建thread
使用类对象作为函数对象的时候需要避免一种C++的语法解析

```c++
class Class{
public:
	void operator()(){}
}
std::thread(Class());		//二重义，可能被解释为函数原型
//解决
std::thread{Class()};
std::thread([](){});
```

以g++作为编译器的时候，直接传递类对象作为函数对象会被复制构造两次
使用智能指针unique_ptr传参数的时候记得使用move把它变成右值再传递否则会报错

```c++
//有问题的代码
void myThread(string&){
    
}
void test(){
    const char*str="asdf";
    thread(myThread,str) t;
    t.detach();				//在这步之前，str一直以指针的形式（虽然被复制过两次了，但是复制的是指针也就是地址，实际指向的位置不变）存在于thread类中，而detach之后才开始正式调用myThread，也就才正式把str传到string的构造函数内new一个新的char数组。而在detach调用的过程中，test可能已经返回，若在这之后myThread才得到调用，可能会导致实际传递的字符串和想传送的字符串不一样
}
```

#### 转移线程所有权

thread删除了复制构造函数，只能使用移动构造函数
删除了复制赋值运算符。有移动赋值运算符，但是如果使用移动赋值运算符的时候如果自身是joinable的，则会失败直接调用terminate

```c++
thread t1(f);
thread t2(t1);			//编译时error，复制构造函数被删除
thread t3(move(t1));	//allowed,调用移动构造函数
thread t4;
t4=t3;					//编译时error,复制赋值运算符被删除了
t4=move(t3);			//allowed,调用移动赋值运算符
t4=thread(f);			//运行时error,调用移动赋值运算符，但是t4是joinable的
void test1(thread&t){}
void test2(thread t){}
test1(t4);			//ok
test1(thread(f));	//ok
test2(t4);			//error
test2(thread(f));	//ok
//使用vector管理thread
vector<thread>threads;
threads.push_back(t4);	//error
threads.push_back(thread(f));	//ok
threads.push_back(move(t4));	//ok
```

#### 线程ID

通过get_id()成员函数获得(若当前thread对象没有和任何线程关链，则返回thread::type默认构造值，表示无线程，thread::type用起来和thread::id一样也可以进行自由比较)，或者通过this_thread::get_id()获得
thread::id类型。可以自由比较（==，<，>）、thread::type也可以进行自由比较

#### 周期

调用析构函数：若这个线程在调用析构函数的时候还处于joinable的状态，则会调用terminate函数
抛出异常：调用terminate函数

#### 成员函数

join()				阻塞主线程，直到子线程运行结束
detach()		   不等待线程运行结束。相当于创建守护进程(后台进程daemon thread)
joinable()		 返回bool指示该线程能不能join。join或detach之后都不是joinable的

hardware_concurrency()		static函数。返回能并发在一个程序中的线程数，如果从系统无法获得相关信息则返回0

### mutex

#### lock_guard

一般不推荐直接使用mutex，而是使用lock_guard(也在\<mutex>头文件内)，它是一个RAII类，会在析构的时候自动调用unlock

```c++
mutex myMutex;
void dosomething(){
    lock_guard<mutex> myGuard(myMutex);
    ....
}
void dosomething(){
    myMutex.lock();
    ...
    myMutex.unlock();
}
```

#### 死锁

1.多个锁（两个以上）在不同方法内按不同顺序上锁
2.无锁的情况下也有可能死锁

#### lock

同时锁住多个mutex，防止死锁的发生。不过还是需要自己unlock每个mutex（可以使用lock_guard(mutex&,adopt_lock_t&)自动在函数结束的时候unlock）

```c++
mutex m1,m2;
void test(){
    lock(m1,m2);						//lock可以同时lock住多个mutex，当获得第一个mutex后获取第二个mutex失败就会发出异常
    lock_guard<mutex>(m1,adopt_lock);		//adopt_lock为adopt_lock_t的一个实例，这个构造方法不会调用mutex的lock，只会在析构函数调用unlock
    lock_guard<mutex>(m2,adopt_lock);
}
```

#### mutex的成员函数

lock()
unlock()



### condition

### variable

### future

## 二维指针

二维指针只能指向指针，不能指向地址

```c++
void testPointer(int length,char**p){
	for(int i=0;i<length;++i){
		cout<<p[i]<<endl;
	}
}
char p[][]={"as","as"};
testPointer(2,p);			//错误
char* p[]={"as","as"};
testPointer(2,p);			//通过
```

## 堆中分配的数组空间连续性

堆中分配的数组内存空间逻辑地址连续，物理地址不连续（跟虚拟内存有关）

## 虚拟内存

## 模板

可以使用非类型参数（编译期替代，类似于宏）

```c++
template<int n>
class Class{
    int s[n];
}
```

c++98对于连续的模板使用，需要空格来分开。但c++11不用

```c++
vector<vecotr<int> >
```

## 异常

try
catch
throw			//编译器会创建一个临时拷贝。而函数内的异常对象将会被清理

throw()		//异常规范。c++98内容，c++11摒弃
noexcept	//函数不抛出异常。c++11内容

throw可以throw所有类型的东西，但是最好是异常类或cosnt char*

```c++
void test()noexcept{
	exception e;	//throw之后e会被清除。实际被抛出去的是编译器创建的一个临时拷贝
	throw e;
}
```

### 问题

堆上分配的内容在遇到异常后可能得不到delete。解决方法就是使用智能指针

### exception

通过调用what函数返回错误报告。可以通过继承覆盖what函数。exception没有构造函数能够指定字符串

**new失败返回bad_alloc异常**。可以通过使用新型new语法禁止在错误发生时返回异常转而返回NULL

```c++
int *p=new(std::nothrow)int;
```

### uncaught exception

未捕获异常。异常规范中定义了但是没有处理的异常

未捕获异常发生了也不会立马终止程序。而是会调用exception头文件中的terminate()。terminate默认调用abort()，可以通过set_terminate(void (*func)())设置terminate调用的函数

### unexpected exception

意外异常。异常规范中没有定义的异常

意外异常发生了会调用exception头文件中的unexpected()，unexpected默认调用terminate()，terminate默认调用abort()。可以通过set_unexpected()设置unexpected的回调函数
但是set_unexpected能设置的函数受到限制。![image-20210916181624241](D:\ALL\Program\c++\note\image-20210916181624241.png)

## 常用C函数

#### 进程控制

abort()			退出程序并返回状态码2
exit(int)		   退出程序并返回指定状态码，int是状态码。在stdlib中（cstdlib）

## RTTI

dynamic_cast    将基类的指针转为派生类的指针，若失败返回空指针
typeid				 返回指出对象类型的type_info。typeid若接受空指针，则返回异常
type_info			存储了有关特定类型的信息。type_info重载了==和!=。方法有：name()

```c++
Base*base=new Child();
Child*child=dynamic_cast<Child*>(base);		//成功返回Child*，失败返回空指针

if(typeid(Base)==typeid(*base)){}
cout<<typeid(*base).name();
```

## string

是**basic_string\<char>**的一个typedef
string::npos设定为string的最大长度。默认为unsigned int的最大值

### 有意思的功能

```c++
//template<typename Iter>string(Iter&begin,Iter&end){...}
char all[]="12346789";
string six(all,all+5);			//six="12345"。通常begin和end也可以是迭代器
```

```c++
//getline可以指定分隔符。指定分隔符后，换行符会变为常规字符而被读取进string
getline(fin,stringInstance,":");
```

```c++
//size()和length()功能一样。都是返回字节数字节数字节字节节。length来自于较早版本的string，size用于兼容STL
```

```c++
//有各种find。如find_first_of
```

```c++
//capacity()返回当前分配给string的内存大小。reserve设置分配给string的内存大小
```

### 字符串种类

```c++
typedef basic_string<char> string;
typedef basic_string<wchar_t> wstring;
typedef basic_string<char16_t> u16string;	//c++11
typedef basic_string<char32_t> u32string;	//c++11
```

## 智能指针

auto_ptr		//c++98,c++11已摒弃
unique_ptr	//c++11
shared_ptr	//c++11

需要包含头文件memory
不要拿栈上的地址赋予智能指针

```c++
std::auto_ptr<int> i(new int);
int ii;
std::auto_ptr<int> ii(&ii);			//运行期间会出错，编译可以通过
```



### auto_ptr和unique_ptr

尽量使用unique_ptr

都会在代码块结束后delete。

有所有权概念，unique_ptr更严格。这两个ptr只能有一个智能指针拥有特定对象，auto_ptr若使用复制。则原来拥有这个对象的智能指针就会删除对这个对象的引用，这个时候使用原来的智能指针会报错。unique_ptr使用复制会在编译期报错(因为删除了复制构造函数和复制赋值构造函数)。若是**右值**（如函数返回值，std::move强制转换为右值），unique_ptr可以通过编译并正常使用

unique_ptr对于new[]分配的内存会使用delete[]，而auto_ptr只会使用delete

**make_unique()**是c++14加入的

```c++
auto_ptr<int>i(new int);
auto_ptr<int>ii=i;
std::cout<<*i;				//segmentation fault

//所有权
auto_ptr<int>i(new int);
auto_ptr<int>ii=i;			//i失去所有权，使用i会在运行期出错
unique_ptr<int>i(new int);
unique_ptr<int>ii=i;		//编译器报错

unique_ptr<int> testPtr(){
    return unique_ptr<int>(new int);
}
unique_ptr<int>i=testPtr();	//不会报错，因为是右值

```

### shared_ptr

会在引用计数为0时delete。使用复制增加引用计数

shared_ptr对于new[]分配的内存不会使用delete[]，只会使用delete。
c++17可以自动识别并delete[]了
c++17前的解决方法：使用std::defalult_delete<>()

**make_shared()**是c++11加入的

```c++
#include <memory>
std::shared_ptr<int[]> sp1(new int[10]()); // 错误，c++17前不能传递数组类型作为shared_ptr的模板参数
std::unique_ptr<int[]> up1(new int[10]()); // ok, unique_ptr对此做了特化

std::shared_ptr<int> sp2(new int[10]()); // 错误，可以编译，但会产生未定义行为，请不要这么做
std::shared_ptr<int> sp3(new int[10](), std::default_delete<int[]>());	//c++17前解决方案
```

c++17前没有重定义operator[]，c++17重定义了operator[]，但是没法使用std::make_shared

### weak_ptr

能够验证指针的有效性，与shared_ptr配合

```c++
#include <iostream>
#include <memory>

int main()
{
    // OLD, problem with dangling pointer
    // PROBLEM: ref will point to undefined data!

    int* ptr = new int(10);
    int* ref = ptr;
    delete ptr;

    // NEW
    // SOLUTION: check expired() or lock() to determine if pointer is valid

    // empty definition
    std::shared_ptr<int> sptr;

    // takes ownership of pointer
    sptr.reset(new int);
    *sptr = 10;

    // get pointer to data without taking ownership
    std::weak_ptr<int> weak1 = sptr;

    // deletes managed object, acquires new pointer
    sptr.reset(new int);
    *sptr = 5;

    // get pointer to new data without taking ownership
    std::weak_ptr<int> weak2 = sptr;

    // weak1 is expired!
    if(auto tmp = weak1.lock())
        std::cout << "weak1 value is " << *tmp << '\n';
    else
        std::cout << "weak1 is expired\n";
    
    // weak2 points to new data (5)
    if(auto tmp = weak2.lock())
        std::cout << "weak2 value is " << *tmp << '\n';
    else
        std::cout << "weak2 is expired\n";
}
```

Output
```c++
weak1 is expired
weak2 value is 5
```

还可以用于解决循环引用

## STL

standard template library（标准模板库）
主要内容是：迭代器 容器 算法 仿函数 内存配置器 配接器

### 容器

对于容器而言，非通用算法（成员函数）通常比通用算法（全局函数）要快
而且通用算法修改容器本身。如std::remove，只能把符合条件的项移动到容器末尾（实际只会移动一个，惰性），并返回一个迭代器指向算法结束后容器中第一个符合条件的项，需要通过容器的erase方法把返回的迭代器作为第一个参数，容器的end()作为第二个参数才能实现真正的删除

插入容器的类型必须是可复制构造和可赋值的

X::iterator			  //迭代器
X::value_type		//存储的数据类型

#### 常用构造器

(Collection&c)
(iterator&begin,iterator&end)
{initialize_list&}

#### 容器共有成员函数

begin()
end()
rbegin()			返回反向迭代器，初始位置和end一样。解除引用前会先++
rend()				返回反向迭代器，初始位置和begin一样。解除引用前会先++
cbegin()			返回const_iterator，c++11
cend()				返回const_iterator，c++11

erase(begin,end)

##### 序列：

![image-20210918095220144](C:\Users\BAZ\AppData\Roaming\Typora\typora-user-images\image-20210918095220144.png)

![image-20210918095006397](D:\ALL\Program\c++\note\image-20210918095006397.png)

![image-20210918095042271](D:\ALL\Program\c++\note\image-20210918095042271.png)

##### 关联容器

X::value_type			值的类型
X::key_type				 键的类型

##### 无序关联容器（C++11）

unorderd_set,unorderd_multiset,unorderd_map,unorderd_multimap

#### ==

因为容器重载的==使用**迭代器**进行比较，所以只比较内容和顺序而**不比较容器类型**。若dequeue和queue内容和顺序一致，则使用==返回true

#### 分配器

template\<class T ,class Allocator=allocator\<T>>
用于管理内存的模板参数，默认使用allocator\<T>，这个类使用new和delete

#### vector

默认迭代器是随机访问迭代器

push_back()


#### list

默认迭代器是双向迭代器

![image-20210918095432899](D:\ALL\Program\c++\note\image-20210918095432899.png)

![image-20210918095610056](D:\ALL\Program\c++\note\image-20210918095610056.png)

#### forward_list

只保留下一个节点的单向list。迭代器为正向迭代器

#### set

默认迭代器是常量迭代器
默认使用less<>（老版C++可能没有默认参数）

std::set_union()			并集。五个参数，前两个是迭代器表示第一个集合区间，第三四个是迭代器表示第二个集合区间，第五个表示输出的位置

```c++
set_union(A.begin(),A.end(),B.begin(),B.end(),istream_iterator<set<string>>(C,C.begin()));
```

std::set_intersection()	交集。与set_union类似
std::set_difference()		差集。与set_union类似

lower_bound()				将键作为参数并返回指向集合中第一个不小于键参数的成员的迭代器
upper_bound()				将键作为参数并返回指向集合中第一个大于键参数的成员的迭代器

#### multiset

#### map

**默认值问题**：使用opertor[]当容器中没有对应的键的时候，返回值的类型的默认值，对于基本类型来说就是基本类型的默认值，对于自建类型来说就是调用默认构造和函数生成的对象

insert当键已经存在的时候返回的pair第二个参数是false，失败。建议直接使用operator[]=

```c++
map<string,int>myMap;
cout<<myMap["a"];			//0
myMap.insert(make_pair("a",1));		//返回pair中的second为false
cout<<myMap["a"];			//0
myMap["a"]=1			//正确设置为1
```

#### multimap

一个键可以对应多个值
默认使用less<>（老版C++可能没有默认值）

count()							以键为参数，返回这个键对应的值的数量
lower_bound()
upper_bound()
equal_range()				以见为参数，返回这个键对应的值的区间的两个迭代器，两个迭代器在pair内，第一个表示开始，第二个表示结尾

#### bitset

#### deque

#### queue

![image-20210918095803733](D:\ALL\Program\c++\note\image-20210918095803733.png)

是个适配器类，底层为dequeue

#### priority_queue

支持的操作和queue一样
是适配器类，底层为vector

默认的时候最大的元素被移动到队首
可以在创建的时候指定比较函数

#### stack

适配器类，底层为vector

![image-20210918100141927](D:\ALL\Program\c++\note\image-20210918100141927.png)

#### array

c++11。严格上不能算STL，因为不能修改长度，但是可以使用很多STL函数如copy()和for_each()
支持operator[] at()

#### complex

C++11。不算STL。复数类

#### valarray

C++11。不算STL。数值数组

#### string

string不是STL的组成部分，但是设计string的时候考虑了STL。拥有begin(),end(),rbegin(),rend()之类的函数

#### 初始化列表语法

c++11新增。initializer_list
容器都有接收这个初始化列表的构造函数
有两种语法:({})和{}。只有有初始化列表的构造函数的时候这种语法才会使用初始化列表。这就代表使用{}初始化**不一定**就是调用的初始化列表构造函数

```c++
std::vector<int>s({1,2,3,4});
std::vector<int>s{1,2,3,4};
```

### 迭代器

使用迭代器的过程中并不会增加容器的大小，所以如果执行一些复制之类的操作，需要提前给容器准备好足够的空间

以下分类只是要求（模板参数），而不是类型（class）。指针就可以当作是一个迭代器（随机访问迭代器）
输入迭代器					//是**单向迭代器**，可以递增，不能倒退。可通过迭代器访问容器数据
输出迭代器					//是**单向迭代器**，可以递增，不能倒退。可通过迭代器写容器数据
正向迭代器					//可读写。单向，但是可以保存正向迭代器
双向迭代器					//可读写。双向
随机访问迭代器

使用需要迭代器的操作时没有选择正确的迭代器会在编译器试图实例化模板的时候报大量的错误

容器中的iterator只是一个typedef，并不代表它具体是什么类的迭代器

**概念**，**模型**

#### iterator头文件下的迭代器

对于copy一类的复制算法建议使用迭代器库中的迭代器，功能比直接使用容器的begin()返回的迭代器完善，就算没有在使用之前设定好容器大小也不会出错

ostream_iterator
istream_iterator
reverse_iterator			递增是递减。例子：rbegin和rend。解除引用之前会先递增（递减）
back_insert_iterator
front_insert_iterator
insert_iterator

### 算法/STL函数

算法的头文件为：\<algorithm>

对于容器而言，非通用算法（成员函数）通常比通用算法（全局函数）要快
而且通用算法修改容器本身。如std::remove，只能把符合条件的项移动到容器末尾（实际只会移动一个，惰性），并返回一个迭代器指向算法结束后容器中第一个符合条件的项，需要通过容器的erase方法把返回的迭代器作为第一个参数，容器的end()作为第二个参数才能实现真正的删除

**算法组**：
非修改式序列操作
修改式序列操作
排序和相关操作
通用数学运算

**按算法结果存放位置分类**：
就地算法			算法结果存放在原始数据的位置
复制算法			结果发送到另一个位置
有些STL算法提供两种类型的方法，一般复制算法版本就以**_copy**结尾
复制算法规定返回一个迭代器，指向复制的最后一个值的后面一个位置

```c++
void replace(ForwordIterator first,ForwordIterator last,const T&old_value,const T&new_value);
//直接把区间内所有old_value转为new_value
OutputIterator replace_copy(ForwordIterator first,ForwordIterator last,OutputIterator result,const T&old_value,const T&new_value);
//把区间内值赋值到result并把old_value转为new_value
```

**_if变体：**

有些函数末尾加上_if表示将容器的值应用到一个函数上，根据函数返回的bool值执行操作

```c++
void replace(ForwordIterator first,ForwordIterator last,const T&old_value,const T&new_value);
//直接把区间内所有old_value转为new_value
void replace_if(ForwordIterator first,ForwordIterator last,Func func,const T&new_value);
//用区间内的值依次调用函数对象，根据函数对象的返回值决定这个值是否变为new_value
```

**\_copy和\_if**可以结合使用，如replace_copy_if

#### 非修改式序列操作

##### find()

##### for_each()

前两个参数是迭代器表示范围，第三个参数是函数对象表示对每一个数据的回调函数

##### count_if()

```c++
int count=count_if(vec.begin(),vec.end(),[](int i){return i%3==0;});
```



#### 修改式序列操作

##### transform()

##### random_shuffle()

两个参数是迭代器表示范围，随机排列区间内元素。要求容器允许随机访问

##### copy()

```c++
vector<int>i;
ostream_iterator<string,char>out(cout," ");
copy(i.begin(),i.end(),out);
```

##### remove()

返回一个迭代器指向最后的符合要求的项，需要使用容器自身的erase方法才能实现删除

```c++
last=std::remove(vec.begin(),vec.end(),4);
vec.erase(last,vec.end());
```

##### unique()

去除容器中重复的数据。使用起来和remove差不多，需要保存返回值

#### 排序和相关操作

##### sort()

前两个参数是迭代器表示范围，第三个参数是函数对象表示执行的比较算法，默认是<。要求容器允许随机访问

##### next_permutation()

将区间内容转为下一种排列组合。若成功返回true，若区间已经是最后一个排列组合则返回false
两个迭代器参数表示区间
单纯通过修改当前排序方式获得排列组合。如果想获得所有排列组合，应该在使用该方法前sort

```c++
std::string str="123";
while(std::next_permutation(str.begin(),str.end())){
    std::cout<<str<<std::endl;
}
```

##### generate()

```c++
generate(vec.begin(),vec.end(),rand)
```



#### 通用数学运算



### 函数对象（函数符）

在头文件functional中

可以使用以函数方式结合使用()的任意对象
函数名，指向函数的指针，重载了()的类的对象（operator()()），以及lambda

#### 分类

生成器					不用参数调用
一元函数				需要一个参数
二元函数				需要两个参数
谓词						返回bool的一元函数
二元谓词				返回bool的二元函数

以上五个分类还有**自适应**版本，即自适应生成器，自适应二元谓词.....。
要成为自适应，需要在类中包括result_type,first_argument_type,second_argument_type的typedef
自适应版本可以使用STL自带适配器：binder1st,binder2nd类和bind1st，bind2nd函数
预定义的函数符都是自适应的

#### 使用

list有一个函数remove_if需要一个函数对象作为参数，对每一个list中的成员调用这个函数对象，若返回true则删除这个成员

```c++
bool tooBig(int x){
	return x>100;
}
list<int>a;
a.remove_if(tooBig);
```

#### 预定义的函数符

老版C++使用timies而不是multiplies

![image-20210918114852184](D:\ALL\Program\c++\note\image-20210918114852184.png)

预定义的函数符都是自适应的

#### 自适应

自适应版本的函数符可以使用STL自带适配器：binder1st,binder2nd类和bind1st，bind2nd函数
建议使用**bind1st和bind2nd**

第一个参数表示需要适配的函数符，第二个参数表示设置的第一个参数。

```c++
std::binder1st<std::plus<int>>(std::plus<int>(),5);
std::bind1st(std::plus<int>(),5);
```

## 流

C++将输出看作**字节流**
所有的数值类型都会被转换为char再输出。如12这个数字会被转换为'1'和'2'再输出

![image-20210919160433271](D:\ALL\Program\c++\note\image-20210919160433271.png)

![image-20210919160452289](D:\ALL\Program\c++\note\image-20210919160452289.png)

![image-20210919165912249](D:\ALL\Program\c++\note\image-20210919165912249.png)

### 缓冲

c++程序一般在键盘按下回车的时候刷新**输入缓冲区**
一般在即将输入的时候刷新**输出缓冲区**
在输出换行符的时候刷新**输出缓冲区**

```c++
cout<<"entry a number";
int i;
cin>>i;//刷新缓冲区
```

flush控制符刷新输出缓冲区
endl控制符刷新输出缓冲区并输出换行符

### 重定向

```bash
#linux
#假设当前目录下有stream这个程序
./stream <input >output 2>errors 3>logfile
```

### 文件尾

控制台输入模拟文件尾：windows和dos是ctrl+z，unix是ctrl+d

### 流对象

cout
cin
cerr
clog
以及以上四个对应的宽字符版本（前面加w）

#### ostream

basic_ostream\<char>的typedef

##### 成员函数

**put(char)**							不是模板方法，只能输出单个字符（可以隐式类型转换）。返回ostream，因此可以拼接使用
**write(charType*,streamsize)** 模板方法，cout默认charType为char。从第一个参数指向的地址开始输出streamsize个charType。可以把int的地址赋给char\*这样就能更简洁地输出int，而不是把int转为char[]再输出
**width()**								返回字段宽度的当前设置。默认的字段宽度为0。字段宽度指的是输出的最小长度
**width(int)**							设置字段宽度并返回之前的字段宽度，这个设置的值只会影响到下一个输出，下一次输出结束后重置字段宽度为默认字段宽度0
**fill(char)**								设置用于填充字段空隙的字符
**precision(int)**						设置浮点数的显示精度，默认精度为6位
**setf(flags)**							设置标记位并返回之前的标记，第一个参数为标记。如ios::showpoint显示浮点数末尾的0和小数点。如2.00默认输出为2，cout.setf(ios::showpoint)之后就会输出2.000000（默认经读为6位）		![image-20210919171822663](D:\ALL\Program\c++\note\image-20210919171822663.png)

**unsetf(flags)**					取消设置

**setf(flags,flags)**				设置标记并返回之前的标记，第一个参数为设置的标记，第二个参数为清除的标记

![image-20210919173131904](D:\ALL\Program\c++\note\image-20210919173131904.png)

##### 控制符

**控制符**一般都是全局函数。ostream里<<有个重载可以调用符合条件的函数
**flush**									刷新缓冲区。是控制符，控制符版本调用全局函数版本。std::cout<<std::flush    std::flush(std::cout)是同意
**endl**									刷新缓冲区并输出换行符。是控制符
**dec**							十进制输出
**hex**							十六进制输出
**oct**							八进制输出

以下**控制符**可代替setf但是老式c++不一定有这些控制符

![image-20210919173719367](D:\ALL\Program\c++\note\image-20210919173719367.png)

![image-20210919173756236](D:\ALL\Program\c++\note\image-20210919173756236.png)

以下**控制符**在iomanip中

setprecision(int)				同precision
setfill(char)						同fill
setw(int)							设置字段宽度（width）

#### istream

basic_istream\<char>的typedef

##### 一些特性

```c++
int i;
char c;
cin>>i		//若输入123Z，则123被输入进i，而Z被保留下来，进入c变量。如果直接输入Zcar，将不会修改i的值，并返回0（cin的标志位设置为false，转换函数返回false(0)）
cin>>c;
```

##### 流状态

![image-20210919175138763](D:\ALL\Program\c++\note\image-20210919175138763.png)

exceptions默认设置为goodbit，就是不会引发异常
流状态被设置后将对之后的输入直接关闭。需要清理流状态并且把问题解决了才能继续使用。若是failbit被设置，则需要把缓冲区中的错误输入清理后才能继续使用

##### 控制符

hex				将输入12当作16进制处理（十进制的18）
oct				将输入12当作8进制来处理
dec				将输入12当作十进制来处理

##### 成员函数

非格式化输入函数，不会跳过空白符：
get(char&)								返回istream&
get(void)									返回的是int或更大的类型,到达文件尾的时候返回EOF（iostream中的一个常量，需要int来存储）
get(char\*,int,char)					读取指定数量的字符或直到遇到分界符，**不会**删除缓冲区中的分界符，若读取完指定的字符后下一个字符不是分界符则istream**不会**设置为fail（可以通过peek()查看下一个字符）。第一个参数指定存储位置，第二个参数指定数量+1(\0)，第三个参数只是分界符（默认为换行符）
getline(char\*,int,char)				读取指定数量的字符或直到遇到分界符，**会**删除缓冲区中的分界符，若读取完指定的字符后下一个字符不是分界符则istream**设置为**fail。第一个参数指定存储位置，第二个参数指定数量+1，第三个参数只是分界符（默认为换行符）
ignore(int,int)							无视指定数量的字符或直到遇到指定的字符。第一个参数指定数量（默认为1），第二个参数指定字符（默认为EOF）。返回istream&
read(char*,int)						读取指定数量的字符，**不会在字符后面自动加上\0**
peek()									返回输入中的下一个字符，但不会抽取输入流中的字符
gcount()								返回最后一个由非格式化输入读取的字符
putback(char)						将指定字符插入到输入流的第一个位置，意味着下一次get将返回这个字符

#### ifstream

basic_ifstream\<char>的typedef，basic_ifstream继承自basic_istream
默认文件模式为ios_base::in

没有复制构造函数，只有移动构造函数

##### 文件模式

![image-20210920103951464](D:\ALL\Program\c++\note\image-20210920103951464.png)

设置binary之后应该使用write和read
使用write输出类类型，不能用来处理指针，因为只会输出地址，而地址每次执行都不一定一样，只能输出不带虚函数的，因为每次程序的执行虚函数的地址都不一定相同

##### 成员函数

is_open()				返回bool，指出是否open成功，直接使用别的方法如bool()重载，.good()方法，都无法检测到以**不合适的文件模式**打开文件的失败
close()					关闭与文件的链接
seekg(streampos)	将输入指针移动到距离文件开头的**特定距离**的位置。
seekg(streamoff,ios_base::seekdir)		将输入指针移动到距离指定的文件位置特定距离的位置。seekdir有三个可能的值，ios::beg文件开头,ios::cur当前光标位置,ios::end文件结尾。streamoff可以是负数
tellg()						返回表示当前位置的streampos值（以字节为单位）

#### ofstream

默认文件模式为ios_base::out|ios_base::trune

##### 文件模式

![image-20210920103951464](D:\ALL\Program\c++\note\image-20210920103951464.png)

设置binary之后应该使用write和read
使用write输出类类型，不能用来处理指针，因为只会输出地址，而地址每次执行都不一定一样，只能输出不带虚函数的，因为每次程序的执行虚函数的地址都不一定相同

```c++
struct S{...};
S s{...}
fout.write((char*)&s,sizeof s);
S temp;
fin.read((char*)&temp,sizeof temp);
```

##### 成员函数

seekp()					
tellp()						返回表示当前位置的streampos值（以字节为单位）

#### fstream

#### 内核格式化

通过流来读取或写入string对象

在头文件sstream中
ostringstream继承自ostream
istringstream继承自istream

## 一些全局函数

isspace(char)		当参数为空白字符的时候返回true

strlen()					计算字符串长度

tmpnam(char*)	 生成临时文件名，结果保存在参数中。在cstdlib中定义，L_tmpnam常量指定了文件名的长度，TMP_MAX指定了能通过这个函数生成的文件名数量。

```c++
char tmp[L_tmpnam]={'\0'}
tmpnam(tmp);
```

## C++11

### 初始化列表

std::initializer_list在\<intitalizer_list>内
1.可以使用{}调用函数
2.禁止窄化

```c++
void testAssist(std::initalizer_list){...}
testAssist({1,2,3});//testAssist{1,2,3}不行

class A{
    public:
    A(std::initalizer_list){...}
}
A{1,2,3};	//可以


char a=111111;		//警告
char s={11111};		//报错

```



### auto

### decltype

```c++
//1
double x=1.5;
int y=1;
decltype(x*y) z;
//2
template<typename T,typename U>
void test(T&t,U&u){
    decltype(t*u) tu;
}
//3
template<typename T,typename U>
auto test(T&t,U&u)->decltype(t*u){
    return t*u;
}
```

### 模板别名

using=

```c++
using itType=std::vector<int>::iterator;

//和typedef区别在于可以用于部分具体化
template<typename T>
using arr12=std::array<T,12>;
```

### nullptr

空指针

### 智能指针

### 摒弃异常规范，使用noexcept

### 作用域内枚举

enum class

### explicit用于转换函数

### 类内成员初始化

类内成员初始化是在C++11才被允许的，以前只能在初始化列表中指定初始化。C++11后，若初始化列表中指定了初始化，则使用初始化列表的初始化覆盖类内成员初始化。

```c++
class A{
	int i=100;	//类内成员初始化，C++11允许
}
```

### foreach

对于**内置类型数组**和实现了**begin()与end()**的类型（如string）或STL容器都能使用foreach语法

### 新的STL容器，新的STL方法

forword_list,unordered_map,unordered_multimap,unordered_set,unordered_multiset,array...(valarray不是C++11才添加的，不过C++11完善了valarray)
cbegin(),cend(),crbegin(),crend()

### 尖括号连用

```c++
std::vector<std::vector<int>>
```

### 右值引用

能出现在赋值表达式左边的是左值，其余的为右值

通过右值引用，导致临时量被存在特殊的位置，因此获得地址，甚至还能修改
const int&:是const左值引用

```c++
int &&i=13;
cout<<&i;
i=15;
```

#### move()

std::move()将参数变为右值返回，在utility文件中

### =delete

取消类中某个特殊函数(构造函数，复制构造函数，复制赋值运算符，移动构造函数，移动赋值运算符，析构函数)默认版本的生成或取消特定的转型

```c++
class A{
	public:
	A(double){}
	A(int)=delete;//间接地禁止从int转型到double
}
A a(3);		//出错
```

### overrider和final

override指定这是覆盖一个基类的虚函数，如果函数原型对不上，将报错。不使用override的时候，函数运行对不上将直接隐藏基类的虚函数
final禁止派生类覆盖某个版本的虚函数

这两个关键字都是现在()之后

```c++
class Base{
    public:
    virtual void f()final{}
}
class Child:public Base{
    public:
    virtual void f()override{}	//出错
}
```

### lambda

```c++
//----持有lambda----
auto f=[](){...};
//------返回类型------
[](){return true;}		//仅当lambda仅由return组成时可以不填写返回类型
[]()->double{double i=123.0;return i;}			//设置返回类型
//-----捕获作用域内变量-------
int nL;
void test(){
    int x;
    int y;
    int z;
    const int n=10;
    [&](){};		//按引用访问所有作用域（test）内变量
    [=](){};		//按值访问所有作用域内变量
    [&x](){};		//按引用访问作用域内x
    [y](){};		//按值访问作用域内y
    [&,x](){}		//按值访问x，按引用访问其他所有作用域内变量
    [=,&x](){}		//按引用访问x，按值访问其他所有变量
    
    [&n](){n=100;}	//错误。因为是const，编译器会识别出const
    [&nL](){}		//错误。nL不在作用域内
}
```

### 包装器（wrapper）

如bind1st,bind2nd
bind,men_fn,reference_wrapper,function

function:
在头文件\<functional>中

```c++
//-----function的用处/template存在的问题--------
template<typename F>
void usef(F&f){
    static int i=0;
    f();
    ++i;
}
void f1(){}//模板参数F解析为void (*)()
void f2(){}//模板参数F解析为void (*)()
class f3{	//模板参数F解析为f3类
public:
    void operator()(){}
}
usef(f1);		//i=1
usef(f2);		//i=2
usef(f3());		//i=1
usef([](){});	//i=1。模板参数F解析为lambda类型
//----------function的使用-------
#include<functional>
function<void(void)>ff1=f1;
function<void(void)>ff3=f3;
function<void(void)>ff4=[](){};
function<void(void)>ff5([](){});
```

### 可变参数函数和模板

可变参数模板：

```c++
template<typename T,typename...Args>	//Args是一个模板参数包
void f(const T&t,const Args&...args){	//args是一个函数参数包
    cout<<t<<",";
    f(args...);		//使用args...展开参数包
}
void f(){}			//基准条件
template<typename T>
void f(const T&t)		//当只剩最后一个的时候调用这个版本,实现判断是否是最后一个从而不输出逗号
	cout<<t<<endl;
}
```

#### 

### 新增库

random		随机数库
tuple			像是pair，但是可以存储任意多个不同类型的值
ratio			表示有理数
regex		正则表达式

### 低级编程

共用体union可以有构造函数和析构函数，但是不能有虚函数

### constptr

### static_assert

assert在\<cassrt>中，static_assrt关键字为C++11引入

## 数组初始化

```c++
char s[5]{'a'};			//第一个元素为'a',其他元素全为0
char s[5]{'a','b'};		//前两个元素为'a'和'b',其他元素全为0
```

## 右移

算术右移和逻辑右移使用的都是>>，具体使用的是逻辑右移还是算术右移取决于类型。如果是unsigned类型则使用逻辑右移，如果是signed类型则使用算术右移

## 编码

原码：正数的原本的编码
反码：除了符号位的所有位取反
补码：反码+1

例子：1的反码：11111110，1的补码11111111

## 浮点数编码



## 大小端

![v2-b5c222f37b547e9d5dac6dfa6031ef18_1440w](D:\ALL\Program\c++\note\v2-b5c222f37b547e9d5dac6dfa6031ef18_1440w.jpg)

x86系列一般是小端模式，网络字节序一般是大端模式

## 抽象类

定义抽象类的时候析构函数应该要定义为虚函数

```c++
class Bass{
public :
	virtual ~Base(){}  //析构函数定义为虚函数，让Base*a=new Child();delete a的时候可以调用child的虚构函数
	virtual operation1()=0;   //纯虚函数
}
```

## cosnt char*和char *cosnt 

```
//const char *指向不可修改的字符串
//char * const指向可修改的字符串但是不能修改这个指针的引用
const int a=10;
const int *aa=&a;
*aa=111;		//错误
int b=12;
int c=13;
int * const  bb=&b;
*bb=150;	//可以执行
bb=&c		//错误

```

## 重载、复写、覆盖的区别

## 动态链接库（也称作共享库（shared））和静态链接库

使用时都需要**头文件**

动态链接库：.so				.dll(在windows下，编译期间还需要使用一个.lib（import library 导入库，包含一些索引信息，与静态链接库的lib不同）协助)
静态链接库：.a				.lib

linux 下编译静态链接库

```
g++ -c static.cpp #生成static.o
ar -crv libstatic.a static.o	#打包成静态库
g++ -L./ -l static	#编译使用libstatic.a,其中-L指定库所在的目录，-l（小写L）指定库名称
```

linux下编译动态链接库：

```
g++ -fPic -c dynamic.cpp		#生成与地址无关的编译程序
g++ -shared -o libdynamic.so dynamic.o	#生成动态链接库
#g++ -fPic -shared -o libdynamic.so dynamic.cpp	#相当于同时做上面两步

```

静态链接库在编译期编译入可执行文件内，生成的可执行文件更大，更耗内存
动态链接库在运行期间加载，更节省内存（多个程序同时加载同一个动态链接库，在内存中只会有一个动态链接库的实例存在），也更容易后期进行修改

## vector的reserve(int)和数字类型的构造函数

reserve重新分配存储区
数字类型的构造函数如vector\<A>(10)会使用A的默认构造函数初始化10个元素

## STL容器

分类：

### 序列容器：vector、deque、list

deque(双端队列)采用多个连续的存储块，因此不会有重新分配内存的行为，还能对头部数据进行常量时间的修改，在大多数情况下表现的和和vector一样好，在最坏情况下（超出已分配的内存）效率比vector好

at()和operator[]（vector和deque都拥有）的区别在于会在越界的情况抛出异常

### 关联容器：set、map、multiset、multimap

multist和multimap不同于set和map在于：multiset和multimap相同的键可以存放多次不同的内容。

```c++
//map的insert方法和operator[]的区别
map<int,string> mp;
mp.insert(make_pair(1,"ww"));			//返回<iterator,bool>|
mp.insert(pair<int,string>(1,"hh"));	//				    |当使用insert插入已经存在的键的时候，忽略这次插入
mp.insert(map<int,string>::value_type(4,"www"));//			 |	三种方法一样
mp[2]="hh";						//1.没找到键为2的pair，先利用string的默认构造函数创建空字符串对象填充mp[2]，接着调用operator=[];2.若找到了键位2的pair，调用operator=
if(mp.find(3)!=mp.end()){			//find方法返回迭代器，当找不到对应的键的时候返回end()。不能使用mp[3]来查询是否存在3这个关键字，因为operator[]当键不存在的时候会直接创建一个默认值的键值对，要查询就使用find或者count
    std::cout<<"find 3 in mp"<<std::endl;
}
if(mp.count(3)==1){				//count方法返回存在键的数量，set和map都只能是0或1，multimap和multiset可以存在重复值所以可以大于1
    std::cout<<"find 3 in mp"<<std::endl;
}
```

```c++
multiset<string> ms;
multimap<int,string> mmp;		//multimap没有operator[]
ms.insert("str");
mmp.insert(make_pair(1,"str"));
pair<multiset<string>::iterator,multiset<string>::iterator>=ms.equal_range("str");//返回迭代器的pair，这个pair的first是匹配内容的起始
```



### 容器适配器：

### 无序关联容器（c++11）：unordered_set

## sizeof

```
int a[10];
sizeof(a);		//40，编译器决定
sizeof(*a)		//4,第一个元素的大小
sizeof(a[0])	//4
int n;
std::cin>>n;
int a[n];
sizeof(a);		//4*n，运行期间决定
```

## 编译器自动生成的类函数

构造函数
拷贝构造函数
复制赋值操作符：当含有引用类型或const的成员变量时不生成，当基类的复制赋值操作符为private时不生成
析构函数
